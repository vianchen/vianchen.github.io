{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/fushcia-permission-model/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Vian Chen"}},"markdownRemark":{"id":"b44e05b2-a6c5-5990-8138-42b97de2cb3b","excerpt":"对象 (objects) Fuchsia 的内核 Zircon 是一个面向对象的内核，它大部分代码使用 C++ 编写，与 UNIX、Linux 程序高度不兼容。 系统内核中的资源均通过“对象”这一概念进行抽象，实际上一个对象就是 C…","html":"<h2>对象 (objects)</h2>\n<p>Fuchsia 的内核 Zircon 是一个面向对象的内核，它大部分代码使用 C++ 编写，与 UNIX、Linux 程序高度不兼容。</p>\n<p>系统内核中的资源均通过“对象”这一概念进行抽象，实际上一个对象就是 C++ 代码中对应数据结构的一个实例。用户模式下的代码需要访问系统资源（即对象）时，必须通过指向对应对象的 handle 来完成，而 handle 实际上也就是一个指向对应 C++ 对象的索引。</p>\n<p>Zircon 常见的对象包括 <strong>进程、线程、事件、虚拟内存</strong> 等。</p>\n<p>在 Zircon 代码中，一些方法的参数只关注宏观意义上的对象，而不关注对象具体是什么；这些代码会使用 <strong><code class=\"language-text\">fbl::RefPtr&lt;Dispatcher></code></strong> 作为参数的类型。（<code class=\"language-text\">Dispatcher</code> 简单来说实现了引用计数和回收复用的特性。）</p>\n<h3>Handle</h3>\n<p>如上文所说，handle 是用户代码访问对象的途径。每个 handle 都是一个二元组 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>P</mi><mo separator=\"true\">,</mo><mi>O</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(P, O)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mclose\">)</span></span></span></span></span>，它既说明了指向的对象 (<em>O</em>)，也表明了这个 handle 所被授予的权限 (<em>P</em>， Zircon 中使用 rights 这个术语来描述权限)。对 handle 或者 handle 所关联的对象进行操作，必须拥有这一操作所需要的特权。</p>\n<blockquote>\n<p>例如，如果一个 handle 拥有 <strong><code class=\"language-text\">ZX_RIGHT_DUPLICATE</code></strong> 权限，则进程可以调用 <code class=\"language-text\">zx_handle_duplicate</code> 系统调用来复制这个 handle，否则不能复制。</p>\n</blockquote>\n<p>Zircon 中的权限大都只与 handle 有关，例如是否允许复制此 handle、是否允许转移此 handle 等，这些权限并不关心 handle 具体涉及什么操作。上层程序的权限实际上是通过对 handle 的管理来实现的，例如是否具有分配内存的权限取决于这个进程是否拥有访问虚拟内存的 handle。</p>\n<p>系统中可以有多个 handle 指向同一个 object，每个进程也可以同时持有多个 handle，但是一个 handle 任一瞬间只能被一个进程持有。Handle 可以在进程之间通过 IPC （channel）进行转移。</p>\n<h2>组件 (components)</h2>\n<p>Fuchsia 组件的概念与沙箱相关。简单来说，Fuschsia 的沙箱是包含了一份程序及其所需要资源的一个容器，它用于保证程序之间的隔离。最原始的沙箱不具有任何权限（包括分配内存的权限），需要由沙箱的创建者为其赋予权限。</p>\n<p>组件可以再组合，即可以组合若干个组件形成一个新的组件。</p>\n<h3>FIDL</h3>\n<p>FIDL 即 Fuchsia Interface Definition Language (Fuchsia 接口定义语言)，它描述了 Fuchsia 上的程序进行进程间通信时所使用的 <strong>协议</strong>，其概念和实现类似于 Google 的另一款产品 <a href=\"https://github.com/protocolbuffers/protobuf\">Protobuf</a>。使用 FIDL 通信的进程遵从客户端—服务器模式，进程 a 作为服务器向外通过协议 <em>A</em> 提供服务，其他进程可以通过各种客户端来访问协议 <em>A</em> 对应的服务。</p>\n<blockquote>\n<p>FIDL 及相关的工具链都不是内核的一部分。FIDL 使用内核中的信道 (channel) 来实现进程间通信，相当于对信道的一种封装，但内核对 FIDL 没有任何知识，也不会知道何时何处哪些进程在使用 FIDL。</p>\n</blockquote>\n<h2>Capability</h2>\n<p>Fuchsia 中的 capability 是一个使用特定 FIDL 协议进行通信的信道，它是组件之间交互的方式，具有某一 capability 的程序可以通过对应的对象访问对应的资源。例如，<code class=\"language-text\">storage</code> capability 允许程序使用 Directory 协议来访问为此组件所创建的持久化存储。能力有三种具体的相关操作：</p>\n<ul>\n<li><code class=\"language-text\">use</code>。当组件 use 一个能力时，<strong>相关的资源将会被安装在组件的命名空间内</strong>。</li>\n<li><code class=\"language-text\">offer</code>。组件可以向其子组件或一个集合 (collection) 提供一个 capability；子组件或集合可以执行 <code class=\"language-text\">use</code> 操作，也可以继续将这个 capability offer 给它的自组件或集合。</li>\n<li><code class=\"language-text\">expose</code>。组件可以向父组件 expose 一个它自己的（或其子组件向其 expose 的）capability；父组件可以对这个 capability 执行 offer 操作。</li>\n</ul>\n<blockquote>\n<p>到这里其实已经能发现，Fuchsia 中的 capability 与 Linux 的并不是一回事儿。Fuchsia 的 capability 已经不是内核的一部分，它是建立在内核上的一套机制。Linux 的 capability 更接近于 Zircon 的 rights。</p>\n</blockquote>\n<h2>References</h2>\n<p>你可参考 Fuchsia 的官方文档（英文）来了解更详细的内容。</p>\n<ol>\n<li><a href=\"https://fuchsia.dev/fuchsia-src/concepts/principles/secure\">Fuchsia 的安全模型</a></li>\n<li><a href=\"https://fuchsia.dev/fuchsia-src/concepts/kernel/rights\">Zircon 内核中的权限 (rights)</a></li>\n<li><a href=\"https://fuchsia.dev/fuchsia-src/concepts/kernel/handles#basics\">Zircon 中的 handle</a></li>\n<li><a href=\"https://fuchsia.dev/fuchsia-src/concepts/components/v2/introduction\">Fuchsia 组件概览</a></li>\n</ol>\n<h2>Glossary</h2>\n<p>由于中文社区尚无约定俗成的翻译，内容中涉及到的术语部分采用了直译方案。下面列出这些术语供对照：</p>\n<ul>\n<li>对象 - objects</li>\n<li>组件 - components</li>\n<li>协议 - protocol</li>\n<li>权限 (Zircon) - rights</li>\n<li>信道 - channel</li>\n</ul>","frontmatter":{"title":"Google Fuchsia 的权限模型","date":"October 28, 2021","description":"有望成为 Android 和 Chrome OS 继任者的 Google 下一代操作系统 Fuchsia 采用了微内核架构，提供了全新的安全和权限模型，使得这一全新操作系统的安全性达到了一个新高度。本文介绍 Fuchsia 权限模型的大体结构。"}},"previous":{"fields":{"slug":"/elgamal-elliptic-curve/"},"frontmatter":{"title":"ElGamal 模运算加密与椭圆曲线加密的类比"}},"next":{"fields":{"slug":"/security-engineering-monopoly/"},"frontmatter":{"title":"信息安全工程中的经济学问题"}}},"pageContext":{"id":"b44e05b2-a6c5-5990-8138-42b97de2cb3b","previousPostId":"8cbf9340-9cad-51d5-bf18-0941ae687d18","nextPostId":"8ba6e455-1ec6-5f34-b97f-31700fd05868"}},
    "staticQueryHashes": ["576393222","642825376"]}