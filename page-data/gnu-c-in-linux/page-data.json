{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/gnu-c-in-linux/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Vian Chen"}},"markdownRemark":{"id":"6469a406-d092-54dc-b398-c5531484ab18","excerpt":"这是我在实验室学习过程中撰写的读书笔记的一部分。随着我提高对相关内容的理解，其中的内容也会随之更新。你可以通过页面尾部的联系方式与我讨论。 这篇文章以 Linux 中比较有代表性的宏为例，向你介绍 Linux 中的 GNU C。 __attribute__((packed)) 假设有如下代码：  是 gcc…","html":"<blockquote>\n<p>这是我在实验室学习过程中撰写的读书笔记的一部分。随着我提高对相关内容的理解，其中的内容也会随之更新。你可以通过页面尾部的联系方式与我讨论。</p>\n</blockquote>\n<p>这篇文章以 Linux 中比较有代表性的宏为例，向你介绍 Linux 中的 GNU C。</p>\n<h2>__attribute__((packed))</h2>\n<p>假设有如下代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">foo</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> x<span class=\"token punctuation\">[</span>z<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>packed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">__attribute__</code> 是 gcc 的一个保留字，用于作属性描述。如果不使用这个保留字，由于 gcc 优先尊重标准 C，则会创建一个名为 <code class=\"language-text\">packed</code> 的变量。</li>\n<li><code class=\"language-text\">packed</code> 属性表示关闭编译器的地址对齐功能。CPU 读取内存通常按块 (chuck) 进行，例如在 x86 架构的计算机上，一个 chuck 大小为 4 bytes（即 32 bits）。为了加速 CPU 对属性的访问，编译器会在属性间加入无意义的内容。具体来说，以 x86 为例：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">foo</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">char</span> b<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/* 2-byte padding */</span>\n\t<span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>单个结构体占用的内存为 8 bytes，而不是 1 + 1 + 4 = 6 bytes（可以使用 gcc 编译，打印 <code class=\"language-text\">sizeof(foo)</code> 试一试）。如果没有 padding，则读取 <code class=\"language-text\">foo.c</code> 需要分两次（先读取第一个 chuck，取后两个字节，再读取第二个 chuck，取前两个字节，拼接在一起形成 <code class=\"language-text\">foo.c</code> ）；有了 padding 之后，读取 <code class=\"language-text\">foo.c</code> 可以一次性完成。</p>\n<ul>\n<li>在 Linux 内核中，内核空间非常宝贵，因此有时需要牺牲效率，使用 <code class=\"language-text\">__attribute__((packed))</code> 关闭这一特性。</li>\n<li>另一个相关的属性是 <code class=\"language-text\">__attribute__((aligned(n)))</code> ，其中 <code class=\"language-text\">n</code> 为整数，表示属性应该按照多少个字节对齐。不难看出 <code class=\"language-text\">aligned(1)</code> 等价于 <code class=\"language-text\">packed</code>。</li>\n<li>编译器还支持伪指令 <code class=\"language-text\">#pragma pack(n)</code> 来描述这一特性。可以使用 <code class=\"language-text\">#pragma ()</code> 来取消这一设置。例如：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">pack</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> </span><span class=\"token comment\">// 取消 padding</span></span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">foo</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">char</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">char</span> b<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">/* no padding */</span>\n\t<span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">pragma</span> <span class=\"token expression\"><span class=\"token function\">pack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> </span><span class=\"token comment\">// 恢复默认设置，即 4 字节对齐</span></span></code></pre></div>\n<h2>container_of</h2>\n<p>在 Linux 5.14.12 中，<code class=\"language-text\">container_of</code> 的定义为：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// from: /include/linux/kernel.h</span>\n\n<span class=\"token comment\">/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n */</span>\n#define <span class=\"token function\">container_of</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\t\t\t\t\\\n\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>__mptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\t\t\t\t\\\n\t<span class=\"token constant\">BUILD_BUG_ON_MSG</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">__same_type</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span>member<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\t\\\n\t\t\t <span class=\"token operator\">!</span><span class=\"token function\">__same_type</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\t\t\t\\\n\t\t\t <span class=\"token string\">\"pointer type mismatch in container_of()\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\\\n\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>__mptr <span class=\"token operator\">-</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这个宏用于获取 <code class=\"language-text\">ptr</code> 这个<strong>指针所指向的对象对应属性所属的对象</strong>，它被大量地用于 Linux 源代码中，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// from: /fs/ext4/ext4.h</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ext4_inode_info</span> <span class=\"token operator\">*</span><span class=\"token function\">EXT4_I</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">inode</span> <span class=\"token operator\">*</span>inode<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">container_of</span><span class=\"token punctuation\">(</span>inode<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">ext4_inode_info</span><span class=\"token punctuation\">,</span> vfs_inode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个例子中，<code class=\"language-text\">*inode</code> 所指向的对象实际上是 <code class=\"language-text\">struct ext4_inode_info</code> 的一个成员，在结构体内，该成员的名称为 <code class=\"language-text\">vfs_inode</code> ，即：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">ext4_inode_info</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// ...</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">inode</span> vfs_inode<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面对 <code class=\"language-text\">container_of</code> 的调用将返回一个指向类型为 <code class=\"language-text\">ext4_inode_info</code> 的对象的指针 <code class=\"language-text\">new_ptr</code>，它满足 <code class=\"language-text\">new_ptr->vfs_inode == *inode</code>。</p>\n<blockquote>\n<p>这个宏在内核的数据结构中有非常重要的作用，例如内核中定义的链表结构就反复使用了这个宏。</p>\n</blockquote>\n<p>为了理解其工作原理，去除中间的调试代码，并将宏转换为易读的伪代码（原来的宏定义没有 <code class=\"language-text\">return</code>，因为使用了 GNU C 的一个<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\">拓展</a>，允许块中最后一条表达式作为整个块的值参与运算），则其定义为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">container_of</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>__mptr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>__mptr <span class=\"token operator\">-</span> <span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> member<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>函数体第一行首先将 <code class=\"language-text\">ptr</code> 转换为任意类型指针，便于后续指针的算数运算；第二行运用到了另一个宏 <code class=\"language-text\">offsetof</code>（当编译器支持时，即等价于 <code class=\"language-text\">__compiler_offsetof</code>；其定义在 <code class=\"language-text\">/include/linux/stddef.h</code>），用于计算结构体某个变量相对于起始地址的偏移量。例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">foo</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">foo</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0</span>\n<span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">foo</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 4</span></code></pre></div>\n<ul>\n<li>\n<p>关于 <code class=\"language-text\">offsetof</code> 的定义</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// from: /include/linux/stddef.h</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">__compiler_offsetof</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">offsetof</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>TYPE<span class=\"token punctuation\">,</span> MEMBER<span class=\"token punctuation\">)</span>\t<span class=\"token function\">__compiler_offsetof</span><span class=\"token punctuation\">(</span>TYPE<span class=\"token punctuation\">,</span> MEMBER<span class=\"token punctuation\">)</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">offsetof</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>TYPE<span class=\"token punctuation\">,</span> MEMBER<span class=\"token punctuation\">)</span>\t<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span><span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TYPE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span>MEMBER<span class=\"token punctuation\">)</span></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span>\n\n<span class=\"token comment\">// from: /include/linux/compiler_types.h</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name function\">__compiler_offsetof</span><span class=\"token expression\"><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\t<span class=\"token function\">__builtin_offsetof</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span></span></span></code></pre></div>\n<p><code class=\"language-text\">__builtin_offsetof</code> 实际上目前版本的 GCC 和 Clang 都支持。如果编译器不支持 <code class=\"language-text\">__builtin_offsetof</code>，则 <code class=\"language-text\">offsetof</code> 的实现 fallback 到程序员手动计算。在大部分编译器上，编译器内置实现和手动计算并无差异，都能实现编译时计算，但后者实际上并非确定的行为，即在某些编译器上，这个值也可能是运行时计算的（见 <a href=\"https://stackoverflow.com/questions/1379298/offsetof-at-compile-time\">References 1</a>），故 Linux 源代码提供了两种实现，没有直接 default 到手动计算。</p>\n</li>\n</ul>\n<h2>__randomize_layout</h2>\n<p>攻击者可能会利用结构体属性的内存排布发起攻击，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">struct foo <span class=\"token punctuation\">{</span>\n\tint val<span class=\"token punctuation\">;</span>\n\tint <span class=\"token operator\">*</span><span class=\"token function\">important_fn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> global_var<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 攻击者：（仅示意）</span>\nextern int <span class=\"token operator\">*</span><span class=\"token function\">malicious_fn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>global_var <span class=\"token operator\">+</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> malicious_fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 此时 global_var 中的 important_fn 指针已被覆盖，</span>\n<span class=\"token comment\">// 指向攻击者的 malicious_fn；</span>\n<span class=\"token comment\">// 系统的后续代码：</span>\nglobal_var<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token function\">important_fn</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 导致恶意函数被调用</span>\n\t\t\t\t\t\t\t\t<span class=\"token comment\">// 遭到攻击！</span></code></pre></div>\n<p>为了避免这种攻击，Linux 使用了 gcc <code class=\"language-text\">randstruct</code> 插件来允许编译器将结构体内属性的内存排布随机打乱，打乱结果由 seed 唯一确定。此插件的三个主要功能：</p>\n<ol>\n<li>任何标记有 <code class=\"language-text\">__randomize_layout</code>  （实际上就是 <code class=\"language-text\">__attribute__((randomize_layout))</code> ，这里又是 Linux 的一个宏定义）的结构体都将随机布局。</li>\n<li>在打开了 <code class=\"language-text\">randstruct</code> 的编译过程，对于所有成员属性均为函数指针的结构体，随机布局会 <em>自动</em> 打开。</li>\n<li>可以使用 <code class=\"language-text\">__no_randomize_layout</code> 显式关闭随机布局（<a href=\"https://lwn.net/Articles/722293/\">Reference 2</a> 给出了需要关闭此功能的案例）。</li>\n</ol>\n<blockquote>\n<p>有些读者可能会想到可以在上面的代码中使用 <code class=\"language-text\">offsetof</code> 来计算偏移量，从而破解随机布局机制，然而 <code class=\"language-text\">offsetof</code> 是编译时的机制，而攻击者攻击的是编译后的二进制，无法调用 <code class=\"language-text\">offsetof</code> 。上面的攻击者代码只是为了演示攻击大概如何发生。（另：打开随机布局后，<code class=\"language-text\">offsetof</code> 的输出也会是符合随机结果的，因此不会破坏 <code class=\"language-text\">container_of</code> 等宏的正确性。）</p>\n</blockquote>\n<p>然而这个方案对于公开分发的 Linux 内核帮助甚小，因为这些内核必须公开自己使用的 seed 来允许第三方内核模块在内核上运行。实际上能够从这一方案中受益的是那些非公开的 Linux 内核，例如 Google 和 Facebook 运行于服务器上的内核。（见 <a href=\"https://lwn.net/Articles/722293/\">Reference 2</a>）</p>\n<h2>Sparse</h2>\n<p>除了上面说到的这些属性以外，还有一些 GCC 会直接忽略的属性，它们被 Linus 开发的 Sparse （见 <a href=\"https://lwn.net/Articles/689907/\">Reference 5</a>）静态分析工具利用。例如 <code class=\"language-text\">__user</code> 的定义：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// /include/linux/compiler_types.h</span>\n# define __user\t\t<span class=\"token function\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>noderef<span class=\"token punctuation\">,</span> <span class=\"token function\">address_space</span><span class=\"token punctuation\">(</span>__user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>也就是说，__user 有两层含义：<code class=\"language-text\">noderef</code> 表示代码中不应该直接解引用使用 <code class=\"language-text\">__user</code> 修饰的指针，以及修饰的指针指向用户空间内存。由于内核能够任意地访问内存，使用 __user 限定符来提醒开发者不要去访问不受信任的内存，乃至后续使用代码检查来避免有关漏洞进入主线，是非常有益处的。开发者使用 Sparse 对代码进行检查时，如果发生了违反这两种情况的代码，会收到报告。可以使用 <code class=\"language-text\">make C=2</code> 来对代码进行检查。</p>","frontmatter":{"title":"Linux 中的 GNU C：代码解读","date":"October 22, 2021","description":"Linux 代码中使用了大量 gcc 的拓展功能来补充 C 的语言特性，在 C 这一表达能力并不是非常强的语言上实现了在其他语言中通常需要使用范型才能实现的通用数据结构。这篇文章带你了解 Linux 使用了哪些语言和编译器特性来完成这一任务。"}},"previous":{"fields":{"slug":"/graduation-thoughts/"},"frontmatter":{"title":"Graduation Thoughts"}},"next":{"fields":{"slug":"/linux-proc-scheduler/"},"frontmatter":{"title":"Linux 的进程创建与调度：代码解读"}}},"pageContext":{"id":"6469a406-d092-54dc-b398-c5531484ab18","previousPostId":"cb884a05-3659-5246-b10d-e314902ecc22","nextPostId":"985e3e1a-9ed2-5be4-bb11-3de512c58061"}},
    "staticQueryHashes": ["576393222","642825376"]}