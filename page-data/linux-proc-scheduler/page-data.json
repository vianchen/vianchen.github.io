{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/linux-proc-scheduler/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Vian Chen"}},"markdownRemark":{"id":"985e3e1a-9ed2-5be4-bb11-3de512c58061","excerpt":"这是我在实验室学习过程中撰写的读书笔记的一部分。随着我提高对相关内容的理解，其中的内容也会随之更新。你可以通过页面尾部的联系方式与我讨论。 下面的内容基于撰文时最新的 Linux 5.14.12 进行分析。 进程的创建 Linux…","html":"<blockquote>\n<p>这是我在实验室学习过程中撰写的读书笔记的一部分。随着我提高对相关内容的理解，其中的内容也会随之更新。你可以通过页面尾部的联系方式与我讨论。</p>\n</blockquote>\n<p>下面的内容基于撰文时最新的 Linux 5.14.12 进行分析。</p>\n<h2>进程的创建</h2>\n<blockquote>\n<p>Linux 的代码没有对进程和线程作明显的区分，因此下面统一使用“进程”这个词来指代二者，具体的语义根据上下文来判断。</p>\n</blockquote>\n<p>Linux 中提供了三个与进程创建相关的系统调用，即 fork、vfork 和 clone。三者的定义都在 <code class=\"language-text\">/kernel/fork.c</code> 文件中，如：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /kernel/fork.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了结构与配置相关的定义</span>\n<span class=\"token function\">SYSCALL_DEFINE0</span><span class=\"token punctuation\">(</span>fork<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">kernel_clone_args</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span>exit_signal <span class=\"token operator\">=</span> SIGCHLD<span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">kernel_clone</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>顺着 <code class=\"language-text\">kernel_clone</code> 的调用向下追踪，则有：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /kernel/fork.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了参数检查和 trace 等内容</span>\n<span class=\"token class-name\">pid_t</span> <span class=\"token function\">kernel_clone</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">kernel_clone_args</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tu64 clone_flags <span class=\"token operator\">=</span> args<span class=\"token operator\">-></span>flags<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n\tp <span class=\"token operator\">=</span> <span class=\"token function\">copy_process</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> trace<span class=\"token punctuation\">,</span> NUMA_NO_NODE<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// ...</span>\n\t<span class=\"token function\">wake_up_new_task</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>通过这段代码不难看出，<code class=\"language-text\">kernel_clone</code> 主要做了两件事：</p>\n<ol>\n<li>复制进程本身；</li>\n<li>唤醒新的进程。</li>\n</ol>\n<p>复制一个进程，不仅仅是要复制 <code class=\"language-text\">task_struct</code> 这个结构体，还需要根据结构体内各个属性的语义以及调用参数去对这些属性进行调整，例如设置新的内存映射等。这些工作都是在 <code class=\"language-text\">copy_process</code> 函数中完成的：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span><span class=\"token function\">kernel_clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /kernel/fork.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了结构与配置相关的定义</span>\n<span class=\"token keyword\">static</span> __latent_entropy <span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span><span class=\"token function\">copy_process</span><span class=\"token punctuation\">(</span>\n\t\t\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">pid</span> <span class=\"token operator\">*</span>pid<span class=\"token punctuation\">,</span>\n\t\t\t\t\t<span class=\"token keyword\">int</span> trace<span class=\"token punctuation\">,</span>\n\t\t\t\t\t<span class=\"token keyword\">int</span> node<span class=\"token punctuation\">,</span>\n\t\t\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">kernel_clone_args</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n\tu64 clone_flags <span class=\"token operator\">=</span> args<span class=\"token operator\">-></span>flags<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 这个函数会复制 task_struct 结构体，具体的过程涉及到 NUMA 相</span>\n\t<span class=\"token comment\">// 关的技术，而 NUMA 与多 CPU 有关。举例来说，在多核心 CPU 上，</span>\n\t<span class=\"token comment\">// 每个核心都有自己的缓存，跨核心的缓存访问会比访问同核心缓存更慢，</span>\n\t<span class=\"token comment\">// 因此 Linux 需要根据情况分配缓存。这种情况下，这里的 node 可以</span>\n\t<span class=\"token comment\">// 理解为核心的 ID。</span>\n\tp <span class=\"token operator\">=</span> <span class=\"token function\">dup_task_struct</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// LSM 钩函数，可参考《Linux 内核安全模块深入剖析》一书</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">security_task_alloc</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> clone_flags<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// if (retval) {} 是在做错误处理，每个中间函数在正常返回时，返回</span>\n\t<span class=\"token comment\">// 值都是 0；如果返回值为非 0，则需要撤销此前的所有操作。为了方便阅</span>\n\t<span class=\"token comment\">// 读，只摘录了第一个这样的错误处理语句。</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>retval<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">goto</span> bad_fork_cleanup_audit<span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_semundo</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_files</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_fs</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_sighand</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_signal</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_mm</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_namespaces</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_io</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_thread</span><span class=\"token punctuation\">(</span>clone_flags<span class=\"token punctuation\">,</span> args<span class=\"token operator\">-></span>stack<span class=\"token punctuation\">,</span> args<span class=\"token operator\">-></span>stack_size<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> args<span class=\"token operator\">-></span>tls<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 如果 pid != &amp;init_struct_pid，说明我们不是在创建内核线程；需</span>\n\t<span class=\"token comment\">// 要分配一个新的 pid。</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pid <span class=\"token operator\">!=</span> <span class=\"token operator\">&amp;</span>init_struct_pid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tpid <span class=\"token operator\">=</span> <span class=\"token function\">alloc_pid</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>nsproxy<span class=\"token operator\">-></span>pid_ns_for_children<span class=\"token punctuation\">,</span> args<span class=\"token operator\">-></span>set_tid<span class=\"token punctuation\">,</span>\n\t\t\t\targs<span class=\"token operator\">-></span>set_tid_size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><span style=\"color: #999\"><em><code class=\"language-text\">__latent_entropy</code> 与密码学有关，可参考 <a href=\"https://hackaday.com/2017/11/02/what-is-entropy-and-how-do-i-get-more-of-it/\">Reference 3</a>。</em></span></p>\n<p>在这些处理中，最重要的是 <code class=\"language-text\">copy_mm</code>，即对进程<strong>虚拟内存的复制</strong>。实际上，在整个进程创建的过程中，最复杂的就是这个部分，以至于 Linus Torvalds 本人在 <code class=\"language-text\">fork.c</code> 文件的开头写道：</p>\n<blockquote>\n<p>Fork is rather simple, once you get the hang of it, but the memory management can be a b***h.（只要你了解了大概，fork 本身很简单；内存管理才是真正烦人的。）</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span><span class=\"token function\">kernel_clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_mm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /kernel/fork.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了一些内容</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">copy_mm</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> clone_flags<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>tsk<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>mm<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>oldmm<span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 如果父进程是一个内核线程，则它是没有用户空间内存的，因此直接返回</span>\n\toldmm <span class=\"token operator\">=</span> current<span class=\"token operator\">-></span>mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>oldmm<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 如果设置了 CLONE_VM 这一 flag，则新进程与其父进程共享虚拟内存，</span>\n\t<span class=\"token comment\">// 即相当于创建的是一个线程。只需要复制 mm 指针即可。</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>clone_flags <span class=\"token operator\">&amp;</span> CLONE_VM<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 调用 mmget 来增加 oldmm 的引用计数</span>\n\t\t<span class=\"token function\">mmget</span><span class=\"token punctuation\">(</span>oldmm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tmm <span class=\"token operator\">=</span> oldmm<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\tmm <span class=\"token operator\">=</span> <span class=\"token function\">dup_mm</span><span class=\"token punctuation\">(</span>tsk<span class=\"token punctuation\">,</span> current<span class=\"token operator\">-></span>mm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mm<span class=\"token punctuation\">)</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token operator\">-</span>ENOMEM<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\ttsk<span class=\"token operator\">-></span>mm <span class=\"token operator\">=</span> mm<span class=\"token punctuation\">;</span>\n\ttsk<span class=\"token operator\">-></span>active_mm <span class=\"token operator\">=</span> mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面代码中，最关键的是 <code class=\"language-text\">dup_mm</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span><span class=\"token function\">kernel_clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_mm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">dup_mm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /kernel/fork.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了一些内容</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span><span class=\"token function\">dup_mm</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>tsk<span class=\"token punctuation\">,</span>\n\t\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>oldmm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>mm<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> err<span class=\"token punctuation\">;</span>\n\n\tmm <span class=\"token operator\">=</span> <span class=\"token function\">allocate_mm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mm<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">goto</span> fail_nomem<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>mm<span class=\"token punctuation\">,</span> oldmm<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>mm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">mm_init</span><span class=\"token punctuation\">(</span>mm<span class=\"token punctuation\">,</span> tsk<span class=\"token punctuation\">,</span> mm<span class=\"token operator\">-></span>user_ns<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">goto</span> fail_nomem<span class=\"token punctuation\">;</span>\n\n\terr <span class=\"token operator\">=</span> <span class=\"token function\">dup_mmap</span><span class=\"token punctuation\">(</span>mm<span class=\"token punctuation\">,</span> oldmm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">goto</span> free_pt<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> mm<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的这段代码大部分都不难理解，可以发现最重要的是 <code class=\"language-text\">dup_mmap</code> 函数：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span><span class=\"token function\">kernel_clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_process</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_mm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">dup_mm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">dup_mmap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /kernel/fork.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了一些内容</span>\n<span class=\"token keyword\">static</span> __latent_entropy <span class=\"token keyword\">int</span> <span class=\"token function\">dup_mmap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>mm<span class=\"token punctuation\">,</span>\n\t\t\t\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">mm_struct</span> <span class=\"token operator\">*</span>oldmm<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>mpnt<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>tmp<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>prev<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>pprev<span class=\"token punctuation\">;</span>\n\tmm<span class=\"token operator\">-></span>total_vm <span class=\"token operator\">=</span> oldmm<span class=\"token operator\">-></span>total_vm<span class=\"token punctuation\">;</span>\n\tmm<span class=\"token operator\">-></span>data_vm <span class=\"token operator\">=</span> oldmm<span class=\"token operator\">-></span>data_vm<span class=\"token punctuation\">;</span>\n\tmm<span class=\"token operator\">-></span>exec_vm <span class=\"token operator\">=</span> oldmm<span class=\"token operator\">-></span>exec_vm<span class=\"token punctuation\">;</span>\n\tmm<span class=\"token operator\">-></span>stack_vm <span class=\"token operator\">=</span> oldmm<span class=\"token operator\">-></span>stack_vm<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>mpnt <span class=\"token operator\">=</span> oldmm<span class=\"token operator\">-></span>mmap<span class=\"token punctuation\">;</span> mpnt<span class=\"token punctuation\">;</span> mpnt <span class=\"token operator\">=</span> mpnt<span class=\"token operator\">-></span>vm_next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\ttmp <span class=\"token operator\">=</span> <span class=\"token function\">vm_area_dup</span><span class=\"token punctuation\">(</span>mpnt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tmm<span class=\"token operator\">-></span>map_count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>tmp<span class=\"token operator\">-></span>vm_flags <span class=\"token operator\">&amp;</span> VM_WIPEONFORK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\tretval <span class=\"token operator\">=</span> <span class=\"token function\">copy_page_range</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">,</span> mpnt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当中最重要的自然是 <code class=\"language-text\">copy_page_range</code> 函数，即对虚存页面的复制。从这里开始，事情就变得复杂起来。简单地说：</p>\n<p><em>P4D、PUD 等为自 Linux 4.11-rc2 进入主线代码的五级页表机制的一部分，大致原理与原书中的三级页表机制类似，具体可见 <a href=\"https://lwn.net/Articles/717293/\">Reference 4</a>。</em></p>\n<ul>\n<li><code class=\"language-text\">copy_page_range</code> 会遍历所有 P4G 并调用 <code class=\"language-text\">copy_p4d_range</code></li>\n<li><code class=\"language-text\">copy_p4d_range</code> 会遍历所有 PUG 并调用 <code class=\"language-text\">copy_pud_range</code></li>\n<li><code class=\"language-text\">copy_pud_range</code> 会遍历所有 PMG 并调用 <code class=\"language-text\">copy_pmd_range</code></li>\n<li><code class=\"language-text\">copy_pmd_range</code> 会遍历所有 PTE 并调用 <code class=\"language-text\">copy_pte_range</code></li>\n<li><code class=\"language-text\">copy_pte_range</code> 会调用 <code class=\"language-text\">copy_present_pte</code> 复制单个 PTE：</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token operator\">></span> \n\t<span class=\"token function\">dup_mmap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_page_range</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span>\n\t<span class=\"token function\">copy_p4d_range</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_pud_range</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span>\n\t<span class=\"token function\">copy_pmd_range</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_pte_range</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span>\n\t<span class=\"token function\">copy_present_pte</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /mm/memory.c</span>\n<span class=\"token comment\">// 下方代码为节选，省略了一些内容</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> <span class=\"token keyword\">int</span>\n<span class=\"token function\">copy_present_pte</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>dst_vma<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">vm_area_struct</span> <span class=\"token operator\">*</span>src_vma<span class=\"token punctuation\">,</span>\n\t\t <span class=\"token class-name\">pte_t</span> <span class=\"token operator\">*</span>dst_pte<span class=\"token punctuation\">,</span> <span class=\"token class-name\">pte_t</span> <span class=\"token operator\">*</span>src_pte<span class=\"token punctuation\">,</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> addr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>rss<span class=\"token punctuation\">,</span>\n\t\t <span class=\"token keyword\">struct</span> <span class=\"token class-name\">page</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>prealloc<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">is_cow_mapping</span><span class=\"token punctuation\">(</span>vm_flags<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">pte_write</span><span class=\"token punctuation\">(</span>pte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">ptep_set_wrprotect</span><span class=\"token punctuation\">(</span>src_mm<span class=\"token punctuation\">,</span> addr<span class=\"token punctuation\">,</span> src_pte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tpte <span class=\"token operator\">=</span> <span class=\"token function\">pte_wrprotect</span><span class=\"token punctuation\">(</span>pte<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这里是最关键的部分。Linux 之所以能非常迅速地创建新进程，得益于其 copy-on-write（写时复制，COW）机制。创建新进程时，父子进程先共享内存页面，直到父子进程其中之一实际上真的要对页面进行写操作时，再去复制该页面。如果 flags 中的设定没有禁止 COW 机制，则不复制该页面，而是将原页面设定为“写保护”，并直接建立新进程与该页面的映射。这样做避免了大量不必要的内存复制，加速了进程创建并节省了内存空间。</p>\n<p><code class=\"language-text\">is_cow_mapping</code> 的定义很清楚地说明了哪些页面可以启用 COW 机制：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /include/linux/mm.h</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">inline</span> bool <span class=\"token function\">is_cow_mapping</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">vm_flags_t</span> flags<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// 只有非共享且可写的页面可以启用 COW</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>flags <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>VM_SHARED <span class=\"token operator\">|</span> VM_MAYWRITE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> VM_MAYWRITE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>共享的页面不能打开 COW 机制，因为打开 COW 机制后页面变为写保护状态，之后对共享内存的写入会触发异常处理。只读的页面似乎也能打开 COW 机制，但其实只读的页面本身就是写保护的，因此没有必要在后面进行新的属性设置，从而稍微加速这个过程。</p>\n<p>当父子进程其中之一尝试向开启了 COW 的页面上写入数据时，由于开启了写保护，会触发系统的异常处理，进入 <code class=\"language-text\">handle_pte_fault</code> 函数，该函数会调用 <code class=\"language-text\">do_wp_page</code> ，进而调用 <code class=\"language-text\">wp_page_copy() > cow_user_page() > copy_user_highpage()</code> 来拷贝页面：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">[</span><span class=\"token operator\">...</span> <span class=\"token operator\">></span> <span class=\"token function\">handle_pte_fault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">do_wp_page</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">wp_page_copy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span>\n\t<span class=\"token function\">cow_user_page</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">copy_user_highpage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /include/linux/highmem.h</span>\n<span class=\"token comment\">// 有一些特殊的 CPU 架构会有自己的实现方案，这里展示的是默认的 fallback 方案</span>\n<span class=\"token keyword\">static</span> inline <span class=\"token keyword\">void</span> <span class=\"token function\">copy_user_highpage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">struct page <span class=\"token operator\">*</span>to<span class=\"token punctuation\">,</span> struct page <span class=\"token operator\">*</span>from<span class=\"token punctuation\">,</span>\n\tunsigned long vaddr<span class=\"token punctuation\">,</span> struct vm_area_struct <span class=\"token operator\">*</span>vma</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tchar <span class=\"token operator\">*</span>vfrom<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>vto<span class=\"token punctuation\">;</span>\n\n\tvfrom <span class=\"token operator\">=</span> <span class=\"token function\">kmap_atomic</span><span class=\"token punctuation\">(</span>from<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 暂时关闭调度并关闭页面异常，建立页面映射</span>\n\tvto <span class=\"token operator\">=</span> <span class=\"token function\">kmap_atomic</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">copy_user_page</span><span class=\"token punctuation\">(</span>vto<span class=\"token punctuation\">,</span> vfrom<span class=\"token punctuation\">,</span> vaddr<span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// memcpy((vto), (vfrom), PAGE_SIZE)</span>\n\t<span class=\"token function\">kunmap_atomic</span><span class=\"token punctuation\">(</span>vto<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">kunmap_atomic</span><span class=\"token punctuation\">(</span>vfrom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面介绍的只是最基本的框架，还有很多边界条件处理的情况没有说明，例如页面实际上可能是由文件通过 mmap 系统调用得来的，此时内存管理又是另一套方案，可自行查阅源码。</p>\n<h2>进程调度</h2>\n<p>Linux 的调度全部发生在 <code class=\"language-text\">__schedule()</code> 函数被调用时，其实现位于 <code class=\"language-text\">/kernel/sched/core.c</code> 中。这个函数在系统内的调用有三种情形：</p>\n<ol>\n<li>使用其他机制显式地导致当前进程阻塞，例如访问互斥锁、信号量等导致当前进程阻塞时；</li>\n<li>中断完成，将从内核态回到用户态，并且设置了 <code class=\"language-text\">TIF_NEED_RESCHED</code> 这一标志时 (<a href=\"https://stackoverflow.com/a/59105973\">Reference 6</a>)；</li>\n<li>进程被唤醒之后某个符合条件的最近时刻。<code class=\"language-text\">wake_up()</code> 并不会立马导致 <code class=\"language-text\">__schedule()</code> 被调用，只是暂时将需要唤醒的进程加入到调度队列中去。对于支持抢占式调用（<code class=\"language-text\">CONFIG_PREEMPTIVE=y</code>）的内核来说，这个“最近时刻”指的是以下事件中最先发生的那个：\n<ol>\n<li>系统调用或异常处理的上下文对 <code class=\"language-text\">preempt_enable()</code> 的调用；</li>\n<li>中断处理结束后回到可抢占的上下文。</li>\n</ol>\n</li>\n</ol>\n<p><code class=\"language-text\">__schedule()</code> 接着会调用 <code class=\"language-text\">pick_next_task() > __pick_next_task()</code> 来选择下一个应当被调度的进程。</p>\n<h3>CFS 调度器</h3>\n<p>为了适用于不同应用场景，我们需要不同的进程调度策略。例如，在一般的应用场景下，我们希望尽可能公平地在各个进程之间分配 CPU 时间，并且允许任务在一定范围内延迟作出响应；而对于一些实时任务，它们要求能立即响应，例如火箭发射过程中对于异常传感器参数的处理就必须是立刻响应，稍微迟缓一些的响应都可能导致致命的后果。为了支持这种需求，Linux 提供了多种调度策略，包括适用于前文提到的实时任务的 <code class=\"language-text\">SCHED_RR</code> 以及普通情况下的 <code class=\"language-text\">SCHED_NORMAL</code>。针对不同的调度策略，调度器又可以被分为多种类别，其中一种类型是 CFS 调度器 (completely fair scheduler)，它是 Linux 进程的默认调度器，实现在 <code class=\"language-text\">/kernel/sched/fair.c</code> 中。</p>\n<p>为了介绍 CFS 调度器，有必要首先介绍其中涉及到的各类概念。</p>\n<p>系统维护了一组队列，称为 <em><strong>运行队列</strong></em>，运行队列中维护的对象称为 <em><strong>调度实体</strong></em>。调度实体可以是一个<strong>进程</strong>（为了方便介绍，后面称为 PSE），也可以是一个<strong>进程组</strong> （后面称为 GSE）。每个 GSE 还有自己的运行队列。</p>\n<blockquote>\n<p>正是因为需要支持按组调度，Linux 才没有直接在队列中维护进程，而是实现了一个抽象度更高的调度实体。支持按组调度的意义有很多，比如两个用户同时在使用一台计算机，那么不仅要保证进程间 CPU 时间分配要相对合理，还要保证用户间分配的合理性，否则一个用户可以创建大量进程来抢占 CPU 时间。</p>\n</blockquote>\n<p>可以将支持了按组调度的运行队列与一个树类比，形成一个多层结构，则树的根节点为这个队列（见下一段），叶节点要么是 PSE，要么是一个空队列；中间节点要么是 GSE，要么是非空队列。</p>\n<p>运行队列又可分为两类：</p>\n<ol>\n<li>普通运行队列，这类运行队列不直接管辖调度实体，而是通过管辖多个子队列来实现调度；每个 CPU 都会有一个普通运行队列。</li>\n<li>调度器专用队列。这些队列均对应一类调度器，如 CFS 队列、RT 队列等。</li>\n</ol>\n<p>普通运行队列的部分定义为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /kernel/sched/sched.h</span>\n<span class=\"token comment\">// 代码为节选</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>\t\tnr_running<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 队列中当前维护的实体数量</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">cfs_rq</span>\t\tcfs<span class=\"token punctuation\">;</span> <span class=\"token comment\">// CFS 子队列</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">rt_rq</span>\t\trt<span class=\"token punctuation\">;</span> <span class=\"token comment\">// RT 子队列</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> __rcu\t<span class=\"token operator\">*</span>curr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当前实际在运行的任务</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>从上面的代码能够看出，普通运行队列管辖了多个调度器专用队列，这些子队列分别对应一种调度器。</p>\n<p>CFS 运行队列的定义为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /include/linux/sched.h</span>\n<span class=\"token comment\">// 代码为节选</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">cfs_rq</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">load_weight</span>\tload<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>\t\tnr_running<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 第一层节点的数量，即 PSE 和 GSE 的数量和</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span>\t\th_nr_running<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 所有层中 PSE 数量的和</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span>\t<span class=\"token operator\">*</span>curr<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 队列当前运行的实体</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span>\t<span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span>\t<span class=\"token operator\">*</span>last<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span>\t<span class=\"token operator\">*</span>skip<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>对于使用 CFS 进行调度的调度实体，其定义为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /include/linux/sched.h</span>\n<span class=\"token comment\">// 代码为节选</span>\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">rb_node</span>\t\t\trun_node<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 红黑树节点</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">list_head</span>\t\tgroup_node<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 进程组节点</span>\n\tu64\t\t\t\tvruntime<span class=\"token punctuation\">;</span> <span class=\"token comment\">// virtual runtime，虚拟单位上的已调度时间</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">CONFIG_FAIR_GROUP_SCHED </span><span class=\"token comment\">// 如果配置选择支持 GSE</span></span>\n\t<span class=\"token keyword\">int</span>\t\t\t\tdepth<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// GSE 的深度</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span>\t\t<span class=\"token operator\">*</span>parent<span class=\"token punctuation\">;</span> <span class=\"token comment\">// GSE 的父组</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">cfs_rq</span>\t\t\t<span class=\"token operator\">*</span>cfs_rq<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当前组在哪一条队列上</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">cfs_rq</span>\t\t\t<span class=\"token operator\">*</span>my_q<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当前组所管辖的那一条队列</span>\n\t<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span>\t\t\trunnable_weight<span class=\"token punctuation\">;</span> <span class=\"token comment\">// my_q->h_nr_running 的缓存</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>从 CFS 调度实体的定义可以看出，CFS 队列实际上是一个<em><strong>红黑树</strong></em>，树根据每个节点的权重来动态调整，从而快速获得下一个应当被调度的实体。</p>\n<p>看完概念，现在回到调度过程中去。当 <code class=\"language-text\">__pick_next_task()</code> 被调用时，它将会根据当前调度队列的情况来选择调度器。如果选用 CFS 调度器，<code class=\"language-text\">__pick_next_task()</code> 调用 <code class=\"language-text\">pick_next_task_fair()</code> ：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">__schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">pick_next_task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">__pick_next_task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">pick_next_task_fair</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /kernel/sched/fair.c</span>\n<span class=\"token comment\">// 代码为节选</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">pick_next_task_fair</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq</span> <span class=\"token operator\">*</span>rq<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>prev<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq_flags</span> <span class=\"token operator\">*</span>rf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">cfs_rq</span> <span class=\"token operator\">*</span>cfs_rq <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rq<span class=\"token operator\">-></span>cfs<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>se<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 下面的循环用于在进程组中最终确定一个进程。见后方代码注释。</span>\n\t<span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>curr <span class=\"token operator\">=</span> cfs_rq<span class=\"token operator\">-></span>curr<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// 调度前，如果当前实体还在队列中，则首先更新当前实体的 vruntime，否则直接忽略</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>curr<span class=\"token operator\">-></span>on_rq<span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token function\">update_curr</span><span class=\"token punctuation\">(</span>cfs_rq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token keyword\">else</span>\n\t\t\t\tcurr <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\tse <span class=\"token operator\">=</span> <span class=\"token function\">pick_next_entity</span><span class=\"token punctuation\">(</span>cfs_rq<span class=\"token punctuation\">,</span> curr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token comment\">// 如果 se 是一个进程组，则 group_cfs_rq 会返回此进程组中的 CFS 运行队列，</span>\n\t\t<span class=\"token comment\">// 否则为 NULL。</span>\n\t\tcfs_rq <span class=\"token operator\">=</span> <span class=\"token function\">group_cfs_rq</span><span class=\"token punctuation\">(</span>se<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>cfs_rq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// 类似于 container_of 的实现</span>\n\tp <span class=\"token operator\">=</span> <span class=\"token function\">task_of</span><span class=\"token punctuation\">(</span>se<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prev <span class=\"token operator\">!=</span> p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 更新运行队列，代码略</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面代码中最重要的部分就是 <code class=\"language-text\">pick_next_entity()</code> ，它决定在当前队列中选取哪一个实体来继续调度。其实现为：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token punctuation\">[</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">__schedule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">pick_next_task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">__pick_next_task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">pick_next_task_fair</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">pick_next_entity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\">// /kernel/sched/fair.c</span>\n<span class=\"token comment\">// 代码为节选</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">pick_next_entity</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">cfs_rq</span> <span class=\"token operator\">*</span>cfs_rq<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>curr<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>left <span class=\"token operator\">=</span> <span class=\"token function\">__pick_first_entity</span><span class=\"token punctuation\">(</span>cfs_rq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 调用红黑树相关借口来获取队列中最靠前的那个实体</span>\n\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>se<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">/*\n\t * 如果当前运行的实体比队列中最靠前的实体还要靠前，则直接更新 left 为当前实体\n\t */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>left <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>curr <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">entity_before</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\tleft <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n\n\tse <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* 理想情况下，最终选定的运行实体就应该是这个最靠前的 */</span>\n\n\t<span class=\"token comment\">/*\n\t * 但是还有一些条件需要注意。只要不会太不公平，要避免运行标记为 skip 的实体。\n\t */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cfs_rq<span class=\"token operator\">-></span>skip <span class=\"token operator\">&amp;&amp;</span> cfs_rq<span class=\"token operator\">-></span>skip <span class=\"token operator\">==</span> se<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">struct</span> <span class=\"token class-name\">sched_entity</span> <span class=\"token operator\">*</span>second<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token comment\">// 挑选一个备选实体来替换当前选择的 se。如果 se 就是当前正在运行的实体，那我们只需要</span>\n\t\t<span class=\"token comment\">// 从队列中选取最左侧的那个实体来替换它。如果 se 不是当前在运行的，则需要从队列中获取</span>\n\t\t<span class=\"token comment\">// se 的下一个节点，并与 curr 进行对比，选择两者之间更靠前的那个。</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>se <span class=\"token operator\">==</span> curr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\tsecond <span class=\"token operator\">=</span> <span class=\"token function\">__pick_first_entity</span><span class=\"token punctuation\">(</span>cfs_rq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t\t\tsecond <span class=\"token operator\">=</span> <span class=\"token function\">__pick_next_entity</span><span class=\"token punctuation\">(</span>se<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 对红黑树相关接口调用的封装</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>second <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>curr <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">entity_before</span><span class=\"token punctuation\">(</span>curr<span class=\"token punctuation\">,</span> second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t\t\tsecond <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token comment\">// wakeup_preempt_entity 用于计算 second 和 left 是否大于某个最小抢占粒度，如果是则</span>\n\t\t<span class=\"token comment\">// 返回 1，否则返回 -1 或 0。简单地说，这个函数在</span>\n\t\t<span class=\"token comment\">//     second->vruntime - left->vruntime &lt;= some_threshold</span>\n\t\t<span class=\"token comment\">// 时返回 -1 或 0，表示此时让 second 运行更符合调度策略、更公平。实际的计算比较复杂，可</span>\n\t\t<span class=\"token comment\">// 自行阅读源码。</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>second <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wakeup_preempt_entity</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t\t\tse <span class=\"token operator\">=</span> second<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cfs_rq<span class=\"token operator\">-></span>next <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wakeup_preempt_entity</span><span class=\"token punctuation\">(</span>cfs_rq<span class=\"token operator\">-></span>next<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 标记为 next 的实体表示某些地方希望这个实体尽可能先运行。只要不会太不公平，就允许优先运行。</span>\n\t\tse <span class=\"token operator\">=</span> cfs_rq<span class=\"token operator\">-></span>next<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cfs_rq<span class=\"token operator\">-></span>last <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wakeup_preempt_entity</span><span class=\"token punctuation\">(</span>cfs_rq<span class=\"token operator\">-></span>last<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 标记为 last 的实体是上次被抢占的实体。只要不会太不公平，考虑到缓存的本地性，优先运行这个实体。</span>\n\t\tse <span class=\"token operator\">=</span> cfs_rq<span class=\"token operator\">-></span>last<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> se<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>进程切换</h3>\n<p>上面的调度过程中已经通过调度器选择了一个进程来执行，接下来就要开始实际地切换进程了。<code class=\"language-text\">__schedule()</code> 接下来将调用 <code class=\"language-text\">context_switch()</code> 来切换任务。<em>切换任务</em>具体的工作，在代码开头的注释中已经说得非常清楚：</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// /kernel/sched/core.c</span>\n<span class=\"token comment\">// 代码为节选</span>\n<span class=\"token comment\">/*\n * context_switch - switch to the new MM and the new thread's register state.\n * 切换到新的内存映射并更新寄存器\n */</span>\n<span class=\"token keyword\">static</span> __always_inline <span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq</span> <span class=\"token operator\">*</span>\n<span class=\"token function\">context_switch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq</span> <span class=\"token operator\">*</span>rq<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>prev<span class=\"token punctuation\">,</span>\n\t       <span class=\"token keyword\">struct</span> <span class=\"token class-name\">task_struct</span> <span class=\"token operator\">*</span>next<span class=\"token punctuation\">,</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">rq_flags</span> <span class=\"token operator\">*</span>rf<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">/*\n\t * kernel -> kernel   lazy + transfer active\n\t *   user -> kernel   lazy + mmgrab() active\n\t *\n\t * kernel ->   user   switch + mmdrop() active\n\t *   user ->   user   switch\n     *\n\t * 上面的注释说明了四种情况。switch 表示需要切换内存映射，lazy 表示不需要\n\t * 切换内存映射。由于内核线程没有自己的内存空间，它将直接沿用用户空间进程的\n     * 内存映射；mmgrab 和 mmdrop 用于引用计数，防止内存映射在其属主进程退出\n     * 后被释放。\n\t */</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>next<span class=\"token operator\">-></span>mm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">// 下一个任务为内核线程</span>\n\t\t<span class=\"token comment\">// 切换到内核线程。在一些架构上这意味着什么也不做，在 x86 上需要更新 TLB。</span>\n\t\t<span class=\"token comment\">// 具体可见该函数的注释。</span>\n\t\t<span class=\"token function\">enter_lazy_tlb</span><span class=\"token punctuation\">(</span>prev<span class=\"token operator\">-></span>active_mm<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\tnext<span class=\"token operator\">-></span>active_mm <span class=\"token operator\">=</span> prev<span class=\"token operator\">-></span>active_mm<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prev<span class=\"token operator\">-></span>mm<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 上一个任务是用户进程</span>\n\t\t\t<span class=\"token comment\">// 递增 prev->active_mm 的引用计数器</span>\n\t\t\t<span class=\"token function\">mmgrab</span><span class=\"token punctuation\">(</span>prev<span class=\"token operator\">-></span>active_mm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">else</span>  <span class=\"token comment\">// 上一个任务是内核线程</span>\n\t\t\tprev<span class=\"token operator\">-></span>active_mm <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\">// 下一个任务为用户进程</span>\n\t\t<span class=\"token comment\">// 退出内核线程</span>\n\t\t<span class=\"token function\">switch_mm_irqs_off</span><span class=\"token punctuation\">(</span>prev<span class=\"token operator\">-></span>active_mm<span class=\"token punctuation\">,</span> next<span class=\"token operator\">-></span>mm<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>prev<span class=\"token operator\">-></span>mm<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>   <span class=\"token comment\">// 上一个任务是内核线程</span>\n\t\t\t<span class=\"token comment\">// 从对称性的角度，应该递减一次 prev->active_mm 的引用计数器；</span>\n\t\t\t<span class=\"token comment\">// 但是这个工作实际上是由 finish_task_switch 来完成</span>\n\t\t\trq<span class=\"token operator\">-></span>prev_mm <span class=\"token operator\">=</span> prev<span class=\"token operator\">-></span>active_mm<span class=\"token punctuation\">;</span>\n\t\t\tprev<span class=\"token operator\">-></span>active_mm <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">/* 更新寄存器和栈。每个结构体系都提供自己的实现。 */</span>\n\t<span class=\"token function\">switch_to</span><span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// 善后工作，包括清理掉状态为 dead 的任务</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">finish_task_switch</span><span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>思考题</h3>\n<p>进程调度非常复杂。上面的介绍实际上略过了很多问题，包括但不限于：</p>\n<ol>\n<li>vruntime 如何更新？</li>\n<li>如何计算每个实体的运行时间？</li>\n<li>队列红黑树如何建立？</li>\n</ol>","frontmatter":{"title":"Linux 的进程创建与调度：代码解读","date":"October 22, 2021","description":"面对复杂的应用场景，Linux 仍然能够非常快速地完成进程的创建，并且实现大量进程的并发运行。这篇文章带你分析 Linux 是如何在代码层面完成这些工作的。"}},"previous":{"fields":{"slug":"/gnu-c-in-linux/"},"frontmatter":{"title":"Linux 中的 GNU C：代码解读"}},"next":{"fields":{"slug":"/elgamal-elliptic-curve/"},"frontmatter":{"title":"ElGamal 模运算加密与椭圆曲线加密的类比"}}},"pageContext":{"id":"985e3e1a-9ed2-5be4-bb11-3de512c58061","previousPostId":"6469a406-d092-54dc-b398-c5531484ab18","nextPostId":"8cbf9340-9cad-51d5-bf18-0941ae687d18"}},
    "staticQueryHashes": ["576393222","642825376"]}